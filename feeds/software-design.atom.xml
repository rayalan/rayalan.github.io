<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Binary Adages - software design</title><link href="https://rayalan.github.io/" rel="alternate"></link><link href="https://rayalan.github.io/feeds/software-design.atom.xml" rel="self"></link><id>https://rayalan.github.io/</id><updated>2024-03-20T00:00:00-04:00</updated><entry><title>Frictionless Change</title><link href="https://rayalan.github.io/frictionless-change-part-3.html" rel="alternate"></link><published>2024-03-20T00:00:00-04:00</published><updated>2024-03-20T00:00:00-04:00</updated><author><name>Alan Ray</name></author><id>tag:rayalan.github.io,2024-03-20:/frictionless-change-part-3.html</id><summary type="html">
&lt;blockquote&gt;
&lt;p&gt;What if a company wanted speed to market to be one of its primary advantages?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://rayalan.github.io/frictionless-change-part-1.html"&gt;At first&lt;/a&gt;, I explored the idea that being able to quickly pivot and ship software to market can be a competitive advantage. &lt;a href="https://rayalan.github.io/frictionless-change-part-2.html"&gt;Last time&lt;/a&gt;, I started a thought experiment about the technical choices that might …&lt;/p&gt;</summary><content type="html">
&lt;blockquote&gt;
&lt;p&gt;What if a company wanted speed to market to be one of its primary advantages?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://rayalan.github.io/frictionless-change-part-1.html"&gt;At first&lt;/a&gt;, I explored the idea that being able to quickly pivot and ship software to market can be a competitive advantage. &lt;a href="https://rayalan.github.io/frictionless-change-part-2.html"&gt;Last time&lt;/a&gt;, I started a thought experiment about the technical choices that might make fast turnaround a true competitive advantage.&lt;/p&gt;
&lt;p&gt;Today, I’m continuing that thought experiment into the organizational choices that would complement the technical choices to achieve this kind of technical advantage.&lt;/p&gt;
&lt;h1 id="intentional-change"&gt;Intentional change&lt;/h1&gt;
&lt;p&gt;The technical practices I suggested last time (e.g. modularity, clearly established patterns, boring flexible technologies) won’t just happen. And despite our desires, technologies well change – Microsoft won’t maintain Windows 95 forever.&lt;/p&gt;
&lt;p&gt;This means we’ll want a careful thoughtful approach to selecting and changing tooling - frameworks, libraries, tools, languages and the like. How do we evaluate a technology? How do we begin to roll it out? How do we evaluate its effectiveness as we roll it out? When do we abort a rollout?&lt;/p&gt;
&lt;p&gt;In particular, we want to avoid the &lt;a href="https://exceptionnotfound.net/lava-flow-the-daily-software-anti-pattern/"&gt;Lava Flow anti-pattern&lt;/a&gt;, either choosing to move fully through with conversions or choosing to fully roll them back.&lt;/p&gt;
&lt;h1 id="cadence-ebb-and-flow"&gt;Cadence: ebb and flow&lt;/h1&gt;
&lt;p&gt;So far, I’ve posited two contradictory directions:
1. The company leverages quick feature turnaround as a competitive advantage.
2. The company carefully builds the capability to quickly turn deliver features.&lt;/p&gt;
&lt;p&gt;These ideas are in tension – as I discussed in my first article, many of the modern attempts to ship features fast to market result in technical debt that slows down future features.&lt;/p&gt;
&lt;p&gt;My solution is a rhythm between shipping features and refining capabilities. Yes, each round of quickly shipped features may add to the tech debt. Somewhere along the line, a developer will use that library maintained by that &lt;a href="https://xkcd.com/2347/"&gt;random person in Nebraska&lt;/a&gt;. That’s fine when we’re shipping quickly. But the refinement cycle needs to go back and find a sustainable solution.&lt;/p&gt;
&lt;p&gt;Likewise, some engineer will realize that the logging statements aren’t right, or that the metric latency is too low, or something. And there will need to be capability improvements in order to continue to rapidly ship features.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It’s like a sword – battle dulls the sword, but no one sharpens a sword just for looks.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alan, reflecting on the balance between shipping software quickly and maintaining capabilities&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This sense of cadence needs to be more than an engineering goal; it needs to be a company goal. If the company leadership doesn’t understand and support the competitive advantage, engineering will constantly be tasked with other priorities – like shipping more features. The result is that if quick turnaround isn’t part of the company strategy, the engineering capability will gradually erode[^erode].&lt;/p&gt;
&lt;h1 id="employees-retention-turnover-and-the-peter-principle"&gt;Employees retention: Turnover and the Peter principle&lt;/h1&gt;
&lt;p&gt;A large part of the company’s strategy for being able to roll out fast changes is well-defined patterns, careful technology transitions, and strong technical decision making. As with most companies, we want employees who learn from their experiences. However, we particularly want employees who have a long-term view to maintaining a key competitive advantage – the speed at which we can ship features.&lt;/p&gt;
&lt;p&gt;This means we want to think carefully about the &lt;a href="https://en.wikipedia.org/wiki/Peter_principle"&gt;Peter principle&lt;/a&gt; – employees get promoted to their level of incompetence and salary ranges. Suppose we have a manager, Jane, who excels at leading a small team on difficult technical projects. That’s an incredibly valuable skill, even if she doesn’t have the skills or temperament to be a director with a wide span of control. So we want to design a system where she isn’t constantly eying a promotion to a director position, either within our company or elsewhere. That starts with compensation, but also includes the kind of respect, latitude, and discretion a manager is given.&lt;/p&gt;
&lt;p&gt;As an example, suppose that a group of managers have a scheduled meeting with a director in a typical organization. The director likely feels far greater freedom to say “Let’s reschedule; something has come up.” than any of the managers do. If it’s a group of developers and a director, this discrepancy is larger. Why does this tendency arise?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The director is assumed to have more important work to do, being higher in the organization.&lt;/li&gt;
&lt;li&gt;The director is assumed to have a better understanding of what is most important across the company.&lt;/li&gt;
&lt;li&gt;The director’s time is far harder to schedule because their calendar is busier.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This kind of signaling – that one’s time would be more valuable if one had this other role – constantly nudge motivated employees into looking elsewhere, even if it isn’t a great fit.&lt;/p&gt;
&lt;p&gt;Likewise, many companies communicate that having a larger span of control is better than having a smaller one. That means that leaders are motivated to grow their headcount, regardless of whether it is actually good for the company. I’ve seen one company, for example, where a department grew tenfold. Each time it grew, there were excellent metrics for how much was getting done – how many tickets were being handled, how heavy the department’s load was, and how great the need for more personnel was. Yet nobody questioned why the there were so many tickets or why the load was heavy; those were simply accepted as givens. Yet behind the scenes, the department was taking on more work and designing workflows that increased their workload. In a different company where importance wasn’t linked to size, conversations would have happened about what work the department actually needed to do, and whether different practices could have reduced the overall workload rather than constantly growing the department.&lt;/p&gt;
&lt;p&gt;At a company that wants to sustain a long-term competitive advantage by having knowledgeable long-term employees in many positions, we want to carefully consider how we’re going to communicate about the relative importance of roles. We don’t want people to be motivated to grow a department except when it actually benefits the company. We don’t want people motivated to seek promotions outside of their skills.&lt;/p&gt;
&lt;p&gt;As an aside, I’m not suggesting that every employee needs to be a long-term employee, but the organization also needs to be very good at recognizing and developing talent, all the better to keep it.&lt;/p&gt;
&lt;h1 id="profit-margins-and-market-landscape"&gt;Profit margins and market landscape&lt;/h1&gt;
&lt;p&gt;So far, we’ve repeatedly made expensive decisions in order to support speed to market. We’re paying non-standard salaries to employees. We’re retaining employees over the long haul. We’ve chose common tools that don’t necessarily offer economies of scale. We’re spending a lot of time to remove tech debt and obstacles to speed. All of these choices take money.&lt;/p&gt;
&lt;p&gt;And the corollary is that we need to be able to afford it. Assuming we’re not able to print money or run a deficit more or less consequence free like the United States government, that means we need profit margins. We need to be doing software development in a space where there are large profit margins that can be capitalized on for a long time – and have a need for being able to swiftly ship new features.&lt;/p&gt;
&lt;p&gt;Not every &lt;a href="https://www.blueoceanstrategy.com/tools/red-ocean-vs-blue-ocean-strategy/"&gt;market landscape&lt;/a&gt; needs both of these criteria. This business approach is probably best situated for a marketplace with low barriers to entry that can’t sustain many competitors. The lack of competitors makes it profitable, and our ability to swift deliver new features when needed allows us to undercut emerging competitors with a unique offering.&lt;/p&gt;
&lt;h1 id="minimize-obstacles-to-change"&gt;Minimize obstacles to change&lt;/h1&gt;
&lt;p&gt;One of the most successful collaborations I had was with an information architect/designer who knew HTML. I was working with him on a project that needed to communicate highly technical detail to non-technical customers. Our process ended up being like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We ended up hammering out the key concepts together&lt;/li&gt;
&lt;li&gt;He’d implement or change the layouts.&lt;ul&gt;
&lt;li&gt;Often, this step completed the worked because the underlying information was already available to the page; it just needed to be displayed.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;He’d mark any places where he didn’t know how to get the information he wanted.&lt;/li&gt;
&lt;li&gt;I’d implement the code that provided the necessary information.&lt;ul&gt;
&lt;li&gt;Often, this step completed the work because the design and formatting was already in place.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If necessary, he’d go back and do a second formatting pass, especially if the information wasn’t exactly in the format he’d anticipated.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Why did this strategy work so well? Because it was often a 0 person handoff process, sometimes a 1 person process, and occasionally a 2 person process.&lt;/p&gt;
&lt;p&gt;Why did this approach work in this case but not in many other situations?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The information architect was enthusiastic about learning an unusual skillset (HTML/Angular) for the work.&lt;/li&gt;
&lt;li&gt;I designed the project so that it was trivial for the information architect to make changes directly to code. For example, I setup a very simple git workflow just for the architect that bypassed a lot of the normal developer complexities.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In software development, hands offs and collaboration are expensive. That’s not to say they aren’t vitally important, but if our goal is fast feature development, we want to think carefully about where and when they are necessary.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Are there non-standard skills we could give certain roles that would streamline work?&lt;/li&gt;
&lt;li&gt;Could certain collaboration be delayed until after features ship?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Overall, the goal is to reduce the obstacles to shipping quality features, not eliminate collaboration or minimize interaction.&lt;/p&gt;
&lt;h1 id="user-expectations-and-change-management"&gt;User expectations and change management&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;How quickly can we drop or change features?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;“Let’s stop collecting the date of their first pet’s birth so that we can drop the Python 2.3 analysis module. It’ll let us ship the new pet friendship feature six months earlier.”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;“We can’t do that without a feature-equivalent alternative. CustomerUno depends on that capability.”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I’ve lost track of how often the ability to make fast changes is sidelined by an old feature that just happens to be critical to one particular customer that’s important to someone in marketing. In short, once a feature gets released and adopted by a customer, it tends to be unremovable.&lt;/p&gt;
&lt;p&gt;On the one hand, this is understandable. Customers buy a product, and seeing features go away feels bad. Seeing them just disappear without notice is worse. On the other hand, this friction is bad for our goals as a company of being able to move fast.&lt;/p&gt;
&lt;p&gt;So what might we do?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Make it really easy to write feature help, onboarding, and change documentation[^change].&lt;/li&gt;
&lt;li&gt;Make significant changes frequently so customers expect it of us.&lt;/li&gt;
&lt;li&gt;Publicize popularity stats for our features so that changes are foreseeable by customers. (I considered making longevity guarantees, but that likely conflicts with our key competitive advantage of being able to ship new features quickly).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[^change] - I see very few live services that do this well. The most common approach seems to be popups that introduce me to new features when I’m in a hurry to get something done, which is, well, suboptimal. This topic probably deserves an article of its own.&lt;/p&gt;
&lt;p&gt;The overall goal is to condition customers to expect change and a certain amount of disruption, and develop a relationship with our customers where they are clear that the disruption with new functionality is a net win for them.&lt;/p&gt;
&lt;h1 id="so-what"&gt;So what&lt;/h1&gt;
&lt;p&gt;Somewhere I read that you can’t beat the industry by following standard industry practices. That is, by definition, standard industry practices produce standard industry results. That doesn’t make standard practices bad. They are, after all, standard for a reason. But sometimes it’s beneficial to take a step back and say “If our goal was really to do such-n-such, how might we structure our company to achieve that goal?”&lt;/p&gt;
&lt;p&gt;I’m certain what I’ve outlined here isn’t the exhaustive list of approaches to achieving fast feature delivery, but I hope readers have enjoyed the thought exercise. What else would you do to optimize for lightning quick feature delivery?&lt;/p&gt;</content><category term="software design"></category><category term="knowledge"></category><category term="uncertainty"></category><category term="smart goals"></category></entry><entry><title>Frictionless Change</title><link href="https://rayalan.github.io/frictionless-change-part-2.html" rel="alternate"></link><published>2024-03-06T00:00:00-05:00</published><updated>2024-03-06T00:00:00-05:00</updated><author><name>Alan Ray</name></author><id>tag:rayalan.github.io,2024-03-06:/frictionless-change-part-2.html</id><summary type="html">
&lt;blockquote&gt;
&lt;p&gt;What if a company wanted speed to market to be one of its primary advantages?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://rayalan.github.io/frictionless-change-part-1.html"&gt;Last time&lt;/a&gt;, I explored the idea that being able to quickly pivot and ship software to market can be a competitive advantage. I touched on the idea that languages that are better able to represent …&lt;/p&gt;</summary><content type="html">
&lt;blockquote&gt;
&lt;p&gt;What if a company wanted speed to market to be one of its primary advantages?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://rayalan.github.io/frictionless-change-part-1.html"&gt;Last time&lt;/a&gt;, I explored the idea that being able to quickly pivot and ship software to market can be a competitive advantage. I touched on the idea that languages that are better able to represent complex concepts – such as &lt;a href="https://en.wikipedia.org/wiki/MapReduce"&gt;MapReduce&lt;/a&gt; – might offer a technical advantage. And I looked at three business pressures that tend to undermine a company’s speed to market.&lt;/p&gt;
&lt;p&gt;Today, I want to do a thought experiment – suppose a business really wanted its time to market for software features to be a competitive advantage – what might it do? This article focuses on the necessary technical choices, and &lt;a href="https://rayalan.github.io/frictionless-change-part-3.html"&gt;part 3&lt;/a&gt; will examine the corresponding employee and business decisions.&lt;/p&gt;
&lt;h1 id="boring-technology"&gt;Boring technology&lt;/h1&gt;
&lt;p&gt;First, &lt;a href="https://mcfunley.com/choose-boring-technology"&gt;choose boring technology&lt;/a&gt;, as described by Dan McKinley. Learning new technologies is expensive. Strange failure modes are expensive. Unknowns are expensive. And since we’re building our company for being able to push features really quickly to market, technological unknowns are really bad. Instead, we want a set of common tools that can reliably and robustly solve any problem that we’re likely to encounter – and quite a few problems that we’re not likely to encounter.&lt;/p&gt;
&lt;p&gt;And yes, this means our solutions may not be performant. They don’t have to be – after all, the competitive advantage we’re after is sustainable speed, not economy of scale.&lt;/p&gt;
&lt;h1 id="change-agnostic-technology"&gt;Change agnostic technology&lt;/h1&gt;
&lt;p&gt;Related to the previous point, we want to choose tools that can be used flexibly.&lt;/p&gt;
&lt;p&gt;Git, for example, excels at this. At its core, it’s a data store organized as a file system with time-oriented sequences and optimized for text.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Why, yes, I’ve used Git as a makeshift database.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alan, on how he’s horrified various coworkers&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It can store code. But it can also store configuration data. Or logs. Or large binaries. Or even function as a makeshift database&lt;sup id="fnref:database"&gt;&lt;a class="footnote-ref" href="#fn:database"&gt;1&lt;/a&gt;&lt;/sup&gt;. I’ve occasionally done all of these, sometimes to the horror of my coworkers. (And we won’t talk about my coworker’s reaction when I suggested turning Stripe’s key:value data storage into an arbitrary data store by splitting JSON strings across multiple keys.)&lt;/p&gt;
&lt;p&gt;My point here is not that Git (or Stripe) &lt;em&gt;should&lt;/em&gt; be used in these ways. But these kinds of generic tools are incredibly flexible, which makes it easy to adapt them to a particular problem.&lt;/p&gt;
&lt;p&gt;In contrast, GitHub is a bad choice here. Yes, it is boring technology. But it also supports very particular workflows. Suppose, for example, that one wants to support reviewing code after it merges? Or a two-staged review process? Or even something “simple” such as unifying tickets and pull requests into a single object?&lt;/p&gt;
&lt;p&gt;All of these changes are hard to do with GitHub. And we want more control over the developer experience so that we can optimize the process for quick turnarounds. This doesn’t mean GitHub is a bad product – it excels at what it does – it just makes it a bad fit for our goals.&lt;/p&gt;
&lt;h1 id="security-and-data-writing-approach"&gt;Security and data writing approach&lt;/h1&gt;
&lt;p&gt;Anytime a company keeps customer-specific data in a centralized location, there are two big risks with shipping a new feature:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;What if those changes give unintended access to some other data?&lt;/li&gt;
&lt;li&gt;What if those changes change how data is written?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After all, a problem displaying data can easily be corrected with a new software update. But if a change goes out and starts writing data incorrectly, then bad data persists even with an update. And if that change also ensured that the correct data isn’t getting written, that’s likely a PR nightmare.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Company loses week’s worth of data&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alan, on how &lt;strong&gt;not&lt;/strong&gt; to earn customer confidence&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So in order to quickly turn around new features, we’re going to want guarantees that our changes don’t alter how we write data (and thus potentially break features) and that they don’t open up privilege escalation or other security vulnerabilities.&lt;/p&gt;
&lt;p&gt;Ideally, we’re going to want those guarantees to be provable through automation. We don’t want to take the time for a human to validate each change, or to risk that the human makes a mistake. Better yet, reliable automated checks here mean that we need less code review before changes are made – if a change can be certified to only impact how data is displayed, then many of the risks to a change go away.&lt;/p&gt;
&lt;p&gt;This implies that we want a very clear architecture for writing and storing data. Perhaps a data store that knows about the individual permissions for each row of data. Each query comes with the intended user, and so a query is incapable of returning results that should not be displayed to the user.&lt;/p&gt;
&lt;p&gt;No doubt that this is a hard problem – that is, in part why there are so many security vulnerabilities – but it’s the kind of problem that we’d solve in order to make truly quick turnaround a competitive advantage.&lt;/p&gt;
&lt;h1 id="established-patterns"&gt;Established patterns&lt;/h1&gt;
&lt;p&gt;The idea of modularity and well-established patterns extends beyond security and data protection. For example, if one is shipping a new feature, there need to be metrics – is the feature working as expected? Is anyone using it? Does anyone like it?&lt;/p&gt;
&lt;p&gt;In a fast turnaround environment, the way that these questions {{{VERB}}} can’t be recreated each time. Instead, the very act of writing a new feature should add the necessary dashboards and metrics. When I write code like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;if FEATURE_FLAG_COOL_NEW_THING:
  page.add(myNewFeature(options))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then that needs to result in the a dashboard for CoolNewThing showing page loads, errors, latency, user interactions, and customer satisfaction – as well as details for how the feature is being used. Maybe there’s even a number correlating the NPS score for users who interact with my feature vs. those who don’t. If there are significant business costs associated with my feature, those should be visible, too. If there are asynchronous behaviors such as outgoing events or generated reports, those should likewise be tracked in the dashboard.&lt;/p&gt;
&lt;p&gt;Likewise, when there is a problem, logging, data lineage, and other debugging resources should have been naturally been populated just by writing the new feature.&lt;/p&gt;
&lt;h1 id="modularity"&gt;Modularity&lt;/h1&gt;
&lt;p&gt;One implication of this approach is careful modularity – the deep awareness of which data writes are going to be affected by a change or the ability to be certain that code only impacts users with a particular feature flag enabled implies a careful attention to the modularity of the software. Pages are going to be written in a particular way so that it is easy to tell – via automated tooling – that these changes only impact one feature’s flags. Data writes are going to be written in a particular way so that code inspection can guarantee that only particular records will be written differently. Certain classes will be used in very particular ways to ensure the right metrics are properly generated.&lt;/p&gt;
&lt;p&gt;And of course, these features need to be easy to use. If they aren’t, the whole idea of fast turnaround for features goes out the window.&lt;/p&gt;
&lt;h1 id="so-what"&gt;So what&lt;/h1&gt;
&lt;p&gt;So far, I’ve looked at a few of the technical aspects of speed as a competitive advantage. &lt;a href="https://rayalan.github.io/frictionless-change-part-3.html"&gt;Next time&lt;/a&gt;, I’ll look at some of the underlying business considerations.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:database"&gt;
&lt;p&gt;High volume throughput won’t work, of course, and one does need an approach for conflict resolution, preferably one that naturally works with Git’s merge strategies. Or, of course, write one’s own merge strategy. &lt;a class="footnote-backref" href="#fnref:database" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="software design"></category><category term="knowledge"></category><category term="uncertainty"></category><category term="smart goals"></category></entry><entry><title>Frictionless Change</title><link href="https://rayalan.github.io/frictionless-change-part-1.html" rel="alternate"></link><published>2024-02-25T00:00:00-05:00</published><updated>2024-02-25T00:00:00-05:00</updated><author><name>Alan Ray</name></author><id>tag:rayalan.github.io,2024-02-25:/frictionless-change-part-1.html</id><summary type="html">
&lt;blockquote&gt;
&lt;p&gt;Being first to market doesn’t matter if you can replicate your competitors’ features instantly.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Joel Spolsky?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A long time ago, someone&lt;sup id="fnref:article"&gt;&lt;a class="footnote-ref" href="#fn:article"&gt;1&lt;/a&gt;&lt;/sup&gt; –&lt;a href="https://www.joelonsoftware.com/"&gt;Joel Spolsky&lt;/a&gt;, if I recall correctly – made a basic point about being in a software business:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;He didn’t worry about competitors rolling out new features.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;He …&lt;/strong&gt;&lt;/p&gt;</summary><content type="html">
&lt;blockquote&gt;
&lt;p&gt;Being first to market doesn’t matter if you can replicate your competitors’ features instantly.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Joel Spolsky?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A long time ago, someone&lt;sup id="fnref:article"&gt;&lt;a class="footnote-ref" href="#fn:article"&gt;1&lt;/a&gt;&lt;/sup&gt; –&lt;a href="https://www.joelonsoftware.com/"&gt;Joel Spolsky&lt;/a&gt;, if I recall correctly – made a basic point about being in a software business:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;He didn’t worry about competitors rolling out new features.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;He worried about competitors who could quickly copy his new features.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Corollary: What matters in one’s own software is the ability to quickly implement the same functionality that a competitor rolls out&lt;sup id="fnref:copy"&gt;&lt;a class="footnote-ref" href="#fn:copy"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;After all, if one can announce the release of feature &lt;em&gt;boil-chicken-with-dumplings&lt;/em&gt; a couple weeks after it makes a big splash, one can:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Keep one’s existing customers (after all, is anyone really leaving over having a new feature two weeks later?)&lt;/li&gt;
&lt;li&gt;Gain new customers who are interested in the feature&lt;/li&gt;
&lt;li&gt;Benefit from the competitor’s hype and marketing around this new capability&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In short, pivoting and reacting quickly mattered. And the main point of Joel’s article was that selecting tools and approaches that enabled that reactivity was a competitive advantage.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Selecting tools and approaches that enabled that reactivity was a competitive advantage.”&lt;/p&gt;
&lt;p&gt;&lt;em&gt;My premise&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://www.joelonsoftware.com/2006/08/01/can-your-programming-language-do-this/"&gt;This article&lt;/a&gt; about Lisp, also by Spolsky, makes a similar point – the more easily one’s language can express complex concepts, the faster one can develop.&lt;/p&gt;
&lt;p&gt;In a rudimentary sense, the whole art of software development is about how to quickly make a computer system do what we want. After all, all software can be reduced to a set of inputs, a set of transformations, and the corresponding outputs. And a &lt;a href="https://en.wikipedia.org/wiki/Turing_machine"&gt;Turing machine&lt;/a&gt; executes every known program.&lt;/p&gt;
&lt;p&gt;But since writing machine instructions on punch cards isn’t fast, a whole industry of tools has emerged: assembly languages, compilers, high-level languages, libraries, memory management and garbage collectors, editors and IDEs, virtual machines, cloud computing – companies adopt these in an attempt to make writing correct software faster&lt;sup id="fnref:faster"&gt;&lt;a class="footnote-ref" href="#fn:faster"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;sup id="fnref:exception"&gt;&lt;a class="footnote-ref" href="#fn:exception"&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h1 id="is-development-faster-a-shifting-goalpost"&gt;Is development faster? A shifting goalpost&lt;/h1&gt;
&lt;p&gt;In the years since I’ve read that article, I’ve often encountered the ideas of speed and agility. In fact, I’ve never met a software executive who wanted engineering to ship features slower or take longer to fix a bug&lt;sup id="fnref:marketing"&gt;&lt;a class="footnote-ref" href="#fn:marketing"&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;So has software development gotten faster?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I don’t know – trying to answer that question is beyond the scope of this article. But there are at least three trends the push in the opposite direction:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Increased expectations.&lt;/li&gt;
&lt;li&gt;Software as a service and vendor lock-in.&lt;/li&gt;
&lt;li&gt;Short-term change with long-term costs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And I want to posit a fourth emergent problem:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Expecting frictionless agility from friction-based tooling.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the rest of this article, I’ll break down these three trends pushing against faster development and then explore the emergent problem in the next entry.&lt;/p&gt;
&lt;h1 id="increased-expectations"&gt;Increased expectations&lt;/h1&gt;
&lt;p&gt;As technology has advanced, expectations have increased for software. For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Customers expect responsive designs that adapt to their device rather than everyone running a universal 640x480 resolution.&lt;/li&gt;
&lt;li&gt;Developers expect meaningful compiler errors, not cryptic “program encountered an error somewhere” messages.&lt;/li&gt;
&lt;li&gt;Gamers expect to easily connect with their online friends, not fight through hours of network configuration menus.&lt;/li&gt;
&lt;li&gt;Designers expect to refresh the look of an application after a few years when it is looking tired.&lt;/li&gt;
&lt;li&gt;Sales expects to be able to create sandbox environments for their prospective enterprise customers to try out.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On top of that, software has become ubiquitous everywhere - doctors and dentists have them, truckers have them, police officers have them, plumbers have them. And that means software needs to be accessible to almost anyone, not experts who have dedicated their lives to using computers.&lt;/p&gt;
&lt;p&gt;And finally, expectations have increased as people see more what software can do. Once I realize how convenient it is to be able to track packages online, I want that ability from every shipping provider. Once I realize how convenient online banking is, I want all my financial institutions to support it. And so on.&lt;/p&gt;
&lt;p&gt;All of these increased expectations makes software harder and slower to develop.&lt;/p&gt;
&lt;h1 id="software-as-a-service-and-vendor-lock-in"&gt;Software-as-a-service and vendor lock-in&lt;/h1&gt;
&lt;p&gt;Every business wants recurring customers. But this creates some weird incentives – if I invent a light bulb that never burns out, how many of them can I sell?&lt;/p&gt;
&lt;p&gt;Maybe 5 per person? Maybe more if I can identify an industrial use for them? But ultimately, the longevity of my lightbulb will cap how many of them I can sell. And so it’s far more profitable for my light bulb to last longer than my competitors’ bulbs…but not forever.&lt;/p&gt;
&lt;p&gt;In many cases, software has hit a similar point. How much better can document writing be? How much better can presentation software be? How much better can home budgeting software be? The reality is that in most cases, the incremental improvements just don’t justify the upgrade price.&lt;/p&gt;
&lt;p&gt;And so many companies, being run by sensible people, have moved to software-as-a-service. And since these companies aren’t interested in losing customers, they’re motivated to make it hard to leave, but not so hard that customers won’t sign up. Sometimes it is forcing people to call rather than being able to cancel a service online. Sometimes it is Apple’s walled garden. Sometimes it is the friction of adapting one’s internal systems.&lt;/p&gt;
&lt;p&gt;Whatever the case, it creates friction to change.&lt;/p&gt;
&lt;p&gt;For example, suppose that my company is currently using GitHub and someone discovers that we will ship software three times as fast if do reviews after code is merged. How quickly can we roll out that change?&lt;/p&gt;
&lt;p&gt;Not very fast. GitHub’s offering is fundamentally rooted in the assumption that pull requests and reviews happen prior to merging. So I basically have three options:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Switch providers.&lt;/li&gt;
&lt;li&gt;Hack together a custom system using various GitHub capabilities.&lt;/li&gt;
&lt;li&gt;Don’t improve the speed we deliver software at.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;None of these are great solutions – (1) and (2) are time consuming and expensive, while (3) doesn’t realize the benefit.&lt;/p&gt;
&lt;h1 id="short-term-changes-with-long-term-costs"&gt;Short-term changes with long-term costs&lt;/h1&gt;
&lt;p&gt;Finally, a lot of software engineering is driven by short-term needs.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The key question is often: How quickly can this feature ship? Time is money, after all.&lt;/li&gt;
&lt;li&gt;Performance reviews often cover six or possibly twelve months – not the cumulative effects of years of decisions.&lt;/li&gt;
&lt;li&gt;People rarely stay at a company – let alone a single position – for more than a few years.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Almost by definition, this creates a situation where there is very little incentive for engineers to make decisions with long-term ramifications in mind. And bizarrely, I’m incentivized to hope that my predecessor left some easy-to-resolve problems so that I can chalk up some easy wins.&lt;/p&gt;
&lt;p&gt;I’ve certainly put others in this situation. In one scenario, for example, I introduced &lt;a href="https://waf.io/book/"&gt;waf&lt;/a&gt; as a non-Makefile solution for complex build patterns. At the time, it was a fantastic solution. But as the company shifted directions over the years, there wasn’t much need for a cross-language Makefile alternative that excelled at minimizing local build times with excellent dependency graphs. The result was that waf slowed down development – too expensive and time consuming to remove, but also too complicated and convoluted for developers to easily make their desired changes.&lt;/p&gt;
&lt;p&gt;There’s even a common architectural anti-pattern that results from this – &lt;a href="https://exceptionnotfound.net/lava-flow-the-daily-software-anti-pattern/"&gt;lava flow&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;And while lava flows can happen in many different ways, here’s a common large-scale pattern I’ve observed:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Observe that a current framework or library is difficult to develop in.&lt;/li&gt;
&lt;li&gt;Propose a new approach that will be far easier and faster to develop in.&lt;/li&gt;
&lt;li&gt;Develop a cost comparison showing that for six months of developer effort, we can save years and years of labor.&lt;/li&gt;
&lt;li&gt;Because backporting all of our existing systems is too time consuming, we’ll only backport a few key systems and do the rest on an as-needed basis.&lt;/li&gt;
&lt;li&gt;Management signs off on the effort.&lt;/li&gt;
&lt;li&gt;The initiative mostly succeeds&lt;sup id="fnref:succeeds"&gt;&lt;a class="footnote-ref" href="#fn:succeeds"&gt;6&lt;/a&gt;&lt;/sup&gt;, although only about 70% of the porting gets done and some promised functionality ends up getting cut for scope.&lt;/li&gt;
&lt;li&gt;Priorities shift, personnel changes, and someone notices that there’s a framework or library that’s difficult to develop in…&lt;/li&gt;
&lt;li&gt;Repeat the process.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;The reality is that each initiative never achieves the expected benefits because it is being constantly sabotaged by the next attempt at improvement.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alan, assessing actual vs. expected benefit&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="so-what"&gt;So what&lt;/h1&gt;
&lt;p&gt;A cynic might look at this evidence and ask: Do companies really believe that speed of delivery is essential to their success?&lt;/p&gt;
&lt;p&gt;Yes, practices such as DevOps, continuous integration, continuous deployment, infrastructure as code, and feature flags are all big steps forward. All too often, though, pressures&lt;sup id="fnref:pressures"&gt;&lt;a class="footnote-ref" href="#fn:pressures"&gt;7&lt;/a&gt;&lt;/sup&gt; such as increased expectations, limited tooling options, and short-term business needs overwhelm the ability to quickly pivot.&lt;/p&gt;
&lt;p&gt;And perhaps the cynic has a point – after all, most public companies are set up to reward quarterly or yearly profits, not decades of sustained profit. Likewise, when was the last time an employee offer included a significant bonus for hitting a decade-long performance metric? How many performance metrics even last a decade?&lt;/p&gt;
&lt;p&gt;But suppose a company really wanted to hone speed to market as a competitive advantage. What might they do? That’s what I’ll consider in &lt;a href="https://rayalan.github.io/frictionless-change-part-2.html"&gt;part 2&lt;/a&gt;.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:article"&gt;
&lt;p&gt;I can’t find the original article; the article on Lisp I reference later is related, but not the one I’m thinking of. &lt;a class="footnote-backref" href="#fnref:article" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:copy"&gt;
&lt;p&gt;The assumption here is that the features being copied are worthwhile and valuable. &lt;a class="footnote-backref" href="#fnref:copy" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:faster"&gt;
&lt;p&gt;I’d categorize security as a form of correct software – software that can be abused for nefarious purposes isn’t correct software. Likewise, since the cost of developers is one of the main costs of development, writing software faster is one of the main ways to reduce costs. &lt;a class="footnote-backref" href="#fnref:faster" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:exception"&gt;
&lt;p&gt;There is exception to this claim that comes to mind, which I’ll address a bit later. &lt;a class="footnote-backref" href="#fnref:exception" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:marketing"&gt;
&lt;p&gt;Emphasis on engineering taking longer; I’ve certainly seen marketing or other business reasons for a feature getting delayed. &lt;a class="footnote-backref" href="#fnref:marketing" title="Jump back to footnote 5 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:succeeds"&gt;
&lt;p&gt;Let’s assume success. Such projects can be a complete disaster, too, of course. &lt;a class="footnote-backref" href="#fnref:succeeds" title="Jump back to footnote 6 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:pressures"&gt;
&lt;p&gt;This list isn’t exhaustive either. Software validation (i.e., testing) and personnel turnover are at least two more areas that push against rapid development. &lt;a class="footnote-backref" href="#fnref:pressures" title="Jump back to footnote 7 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="software design"></category><category term="knowledge"></category><category term="uncertainty"></category><category term="smart goals"></category></entry></feed>